# exercise-4

## More data types: `dict`

* Last week, you learned about the list, which a way of organising objects in an ordered way. Remember the syntax: `mylist = ["What", "a", "nice", "day"]`. These objects, however, can only be accessed by their `index` in this way, for example: `mylist[2]`.
* The list can contain any type of objects, including any of the data types we have seen so far: the `int` (for *integer*, which is a number), the `boolean` (which can be either `True` or `False`) and the `string`.
* Remember also, that we use `python path/to/file.py` to instruct the *interpreter* to run our code. The interpreter reads the code and tries to translate it into actions. For it to understand the code, the code needs to adhere to the language rules of `python`.

ðŸŽ‰ There's another way to store objects in an organised way in `python`: the `dict` for *dictionary*. Dictionaries are `{ key : value }`-pairs, which are declared exactly in that way. The `key` is a `string`, the `value` can be anything. For example, you can use a `python dict` to implement a dictionary in the classical sense: `french_dict = { "katze" : "chat", "stuhl" : "chaise" }` and use it as follows: `french_dict["katze"]`.
* To go through all the elements in a `list`, you use this syntax: `for item in mylist`. To iterate through a `dict`, however, you use: `for key, value in mydict.items()`.
* But you can also use different types in a `dict` like this `{ "name" : "rudolf", "points" : 1, "is_reindeer" : True, "likes" : [ "truffles", "carrots"] }`.

## exercise-4

ðŸ•° Submit your exercise at least 15' before the next session starts. 

1. Read the [original paper](https://tartarus.org/martin/PorterStemmer/def.txt) about the Porter stemmer. 
2. Check out the `exercise-4/porter.py` file and the sample code. All of the conditions that are described in the paper have already been programmed. You can test them by calling the method in question at the end of the file, such as `print(ends_in_cvc("cococ"))`.
3. The first step of stage 1A also has been written for you already, so you can get an idea how to proceed.
4. Implement `stage_1a` and all the other stages, and test your code with `pytest`.

ðŸ’¡ Take special note of this part: *In a set of rules written beneath each other, only one is obeyed, and this will be the one with the longest matching*
ðŸ’¡ Watch out: `*v*` means to test if the *stem* of a word contains a vowel, that is, the word without the suffix in question. Likewise, the conditions regarding the measure also apply only to the *measure of the stem*!
ðŸ’¡ If a suffix matches a rule, but the condition does not, the rule is not applied and the other rules for the step are not matched! (This is how, for example, *feed* is not subjected to the `ED ->` rule in step 1b.)
ðŸ’¡ Because step 1b is the hardest step, there's already some code to help you. Try to understand it, as it might make it easier for you to solve the other exercises, but don't worry too much if you don't. Mimic the code that is already in `def step_1b()` to finish that step and move on.